{"version":3,"file":"xterm-addon-attach.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAqB,YAAID,IAEzBD,EAAkB,YAAIC,GACvB,CATD,CASGK,MAAM,I,gDC0ET,SAASC,EAAqDC,EAAmBC,EAASC,GAExF,OADAF,EAAOG,iBAAiBF,EAAMC,GACvB,CACLE,QAAS,KACFF,GAILF,EAAOK,oBAAoBJ,EAAMC,EAAQ,EAG/C,C,sEAjFA,oBAKEI,YAAYN,EAAmBO,GAFvB,KAAAC,aAA8B,GAGpCC,KAAKC,QAAUV,EAEfS,KAAKC,QAAQC,WAAa,cAC1BF,KAAKG,iBAAmBL,IAAqC,IAA1BA,EAAQM,cAC7C,CAEOC,SAASC,GACdN,KAAKD,aAAaQ,KAChBjB,EAAkBU,KAAKC,QAAS,WAAWO,IACzC,MAAMC,EAA6BD,EAAGC,KACtCH,EAASI,MAAsB,iBAATD,EAAoBA,EAAO,IAAIE,WAAWF,GAAM,KAItET,KAAKG,iBACPH,KAAKD,aAAaQ,KAAKD,EAASM,QAAOH,GAAQT,KAAKa,UAAUJ,MAC9DT,KAAKD,aAAaQ,KAAKD,EAASQ,UAASL,GAAQT,KAAKe,YAAYN,OAGpET,KAAKD,aAAaQ,KAAKjB,EAAkBU,KAAKC,QAAS,SAAS,IAAMD,KAAKL,aAC3EK,KAAKD,aAAaQ,KAAKjB,EAAkBU,KAAKC,QAAS,SAAS,IAAMD,KAAKL,YAC7E,CAEOA,UACL,IAAK,MAAMqB,KAAKhB,KAAKD,aACnBiB,EAAErB,SAEN,CAEQkB,UAAUJ,GACXT,KAAKiB,oBAGVjB,KAAKC,QAAQiB,KAAKT,EACpB,CAEQM,YAAYN,GAClB,IAAKT,KAAKiB,mBACR,OAEF,MAAME,EAAS,IAAIR,WAAWF,EAAKW,QACnC,IAAK,IAAIC,EAAI,EAAGA,EAAIZ,EAAKW,SAAUC,EACjCF,EAAOE,GAA0B,IAArBZ,EAAKa,WAAWD,GAE9BrB,KAAKC,QAAQiB,KAAKC,EACpB,CAEQF,mBACN,OAAQjB,KAAKC,QAAQsB,YACnB,KAAKC,UAAUC,KACb,OAAO,EACT,KAAKD,UAAUE,WACb,MAAM,IAAIC,MAAM,kDAClB,KAAKH,UAAUI,QAEb,OADAC,QAAQC,KAAK,mCACN,EACT,KAAKN,UAAUO,OACb,MAAM,IAAIJ,MAAM,iCAClB,QACE,MAAM,IAAIA,MAAM,2BAEtB,E","sources":["webpack://AttachAddon/webpack/universalModuleDefinition","webpack://AttachAddon/./src/AttachAddon.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"AttachAddon\"] = factory();\n\telse\n\t\troot[\"AttachAddon\"] = factory();\n})(self, () => {\nreturn ","/**\n * Copyright (c) 2014, 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n *\n * Implements the attach method, that attaches the terminal to a WebSocket stream.\n */\n\nimport { Terminal, IDisposable, ITerminalAddon } from 'xterm';\n\ninterface IAttachOptions {\n  bidirectional?: boolean;\n}\n\nexport class AttachAddon implements ITerminalAddon {\n  private _socket: WebSocket;\n  private _bidirectional: boolean;\n  private _disposables: IDisposable[] = [];\n\n  constructor(socket: WebSocket, options?: IAttachOptions) {\n    this._socket = socket;\n    // always set binary type to arraybuffer, we do not handle blobs\n    this._socket.binaryType = 'arraybuffer';\n    this._bidirectional = !(options && options.bidirectional === false);\n  }\n\n  public activate(terminal: Terminal): void {\n    this._disposables.push(\n      addSocketListener(this._socket, 'message', ev => {\n        const data: ArrayBuffer | string = ev.data;\n        terminal.write(typeof data === 'string' ? data : new Uint8Array(data));\n      })\n    );\n\n    if (this._bidirectional) {\n      this._disposables.push(terminal.onData(data => this._sendData(data)));\n      this._disposables.push(terminal.onBinary(data => this._sendBinary(data)));\n    }\n\n    this._disposables.push(addSocketListener(this._socket, 'close', () => this.dispose()));\n    this._disposables.push(addSocketListener(this._socket, 'error', () => this.dispose()));\n  }\n\n  public dispose(): void {\n    for (const d of this._disposables) {\n      d.dispose();\n    }\n  }\n\n  private _sendData(data: string): void {\n    if (!this._checkOpenSocket()) {\n      return;\n    }\n    this._socket.send(data);\n  }\n\n  private _sendBinary(data: string): void {\n    if (!this._checkOpenSocket()) {\n      return;\n    }\n    const buffer = new Uint8Array(data.length);\n    for (let i = 0; i < data.length; ++i) {\n      buffer[i] = data.charCodeAt(i) & 255;\n    }\n    this._socket.send(buffer);\n  }\n\n  private _checkOpenSocket(): boolean {\n    switch (this._socket.readyState) {\n      case WebSocket.OPEN:\n        return true;\n      case WebSocket.CONNECTING:\n        throw new Error('Attach addon was loaded before socket was open');\n      case WebSocket.CLOSING:\n        console.warn('Attach addon socket is closing');\n        return false;\n      case WebSocket.CLOSED:\n        throw new Error('Attach addon socket is closed');\n      default:\n        throw new Error('Unexpected socket state');\n    }\n  }\n}\n\nfunction addSocketListener<K extends keyof WebSocketEventMap>(socket: WebSocket, type: K, handler: (this: WebSocket, ev: WebSocketEventMap[K]) => any): IDisposable {\n  socket.addEventListener(type, handler);\n  return {\n    dispose: () => {\n      if (!handler) {\n        // Already disposed\n        return;\n      }\n      socket.removeEventListener(type, handler);\n    }\n  };\n}\n"],"names":["root","factory","exports","module","define","amd","self","addSocketListener","socket","type","handler","addEventListener","dispose","removeEventListener","constructor","options","_disposables","this","_socket","binaryType","_bidirectional","bidirectional","activate","terminal","push","ev","data","write","Uint8Array","onData","_sendData","onBinary","_sendBinary","d","_checkOpenSocket","send","buffer","length","i","charCodeAt","readyState","WebSocket","OPEN","CONNECTING","Error","CLOSING","console","warn","CLOSED"],"sourceRoot":""}